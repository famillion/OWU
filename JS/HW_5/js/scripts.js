//// ================================================ HOME WORK 5 ===========================================================

////======================================= 1 ==========================================================================
// //
// // ==============================================
// //     -  Створити функцію конструктор для об'єкту який описує теги
// // Властивості
// // -назва тегу
// // - опис його дій
// // - масив з атрибутами (2-3 атрибути максимум)
// // Кожен атрибут описати як окремий який буде містити
// // -назву атрибуту
// // -опис дії атрибуту
// // інформацію брати з htmlbook.ru
// //
// // Таким чином описати теги
// // -a
// // -div
// // -h1
// // -span
// // -input
// // -form
// // -option
// // -select
// // Приклад результату
// // {
// //     titleOfTag: 'area',
// //         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
// //     attrs: [
// //     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
// //     {/*some props and values*/},
// //     {/*...*/},
// //     {/*...*/},
// // ]
// //
// // }
//
//
// function HtmlBook(tagName, tagDesr, atrArr) {
//     this.tagName = tagName;
//     this.tagDescr = tagDesr;
//     this.attributes = [...atrArr];
// }
//
// function HtmlAtr(atrName, atrDesr) {
//     this.atrName = atrName;
//     this.atrDesr = atrDesr;
// }
//
// //// ************** tag a ******************
//
// let aDescr = 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. ' +
//     'В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. ' +
//     'Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки.' +
//     ' При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы.';
//
// let aAtrArr = [];
//
// let aAtrHrefObj = new HtmlAtr('href', 'Задает адрес документа, на который следует перейти. ' +
//     'Поскольку в качестве адреса ссылки может использоваться документ любого типа, то результат перехода ' +
//     'по ссылке зависит от конечного файла. Так, архивы (файлы с расширением zip или rar) будут сохраняться' +
//     ' на локальный диск. По умолчанию новый документ загружается в текущее окно браузера, однако это свойство ' +
//     'можно изменить с помощью атрибута target.');
// aAtrArr.push(aAtrHrefObj);
//
// let aAtrDownloadObj = new HtmlAtr('download', 'При наличии атрибута download браузер не переходит' +
//     ' по ссылке, а предложит скачать документ, указанный в адресе ссылки.');
// aAtrArr.push(aAtrDownloadObj);
//
// let aAtrTargetObj = new HtmlAtr('target', 'По умолчанию, при переходе по ссылке документ открывается ' +
//     'в текущем окне или фрейме. При необходимости, это условие может быть изменено атрибутом target тега <a>. ' +
//     'В XHTML применение этого атрибута запрещено.');
// aAtrArr.push(aAtrTargetObj);
//
// let aTag = new HtmlBook('a', aDescr, aAtrArr);
//
// console.log(aTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag div ******************
//
// let divDescr = 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа' +
//     ' с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать ' +
//     'каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить ' +
//     'атрибут class или id с именем селектора.';
//
// let divAtrAlignObj = new HtmlAtr('align', 'Выравнивание содержимого контейнера <div> по краю.');
// let divAtrTitleObj = new HtmlAtr('title', 'Добавляет поясняющий текст к контейнеру <div> в виде' +
//     ' всплывающей подсказки, которая отображается, когда курсор мыши задерживается на содержимом.');
//
// let divAtrArr = [divAtrAlignObj, divAtrTitleObj];
//
// let divTag = new HtmlBook('div', divDescr, divAtrArr);
//
// console.log(divTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag h1 ******************
//
// let h1Descr = 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции,' +
//     ' расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня,' +
//     ' а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. ' +
//     'По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, ' +
//     'заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, ' +
//     'они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. ' +
//     'Кроме того, перед заголовком и после него добавляется пустое пространство.';
//
// let h1AtrDirObj = new HtmlAtr('dir', 'Задает направление и отображение текста — слева направо' +
//     ' или справа налево. Браузеры обычно самостоятельно различают направление текста, если он задан в кодировке Юникод,' +
//     ' но с помощью атрибута dir можно указать, в каком направлении отображать текст. Для арабских и еврейских символов' +
//     ' приоритетным является направление, заложенное в Юникод, поэтому на них атрибут dir действовать не будет.');
//
// let h1AtrContextObj = new HtmlAtr('contextmenu', 'Устанавливает контекстное меню для элемента.');
//
// let h1AtrContentObj = new HtmlAtr('contenteditable', 'Сообщает, что элемент доступен для редактирования' +
//     ' пользователем — можно удалять текст и вводить новый. Также работают стандартные команды вроде отмены, вставки' +
//     ' текста из буфера и др.');
//
// let h1ArtArr = [h1AtrDirObj, h1AtrContextObj, h1AtrContentObj];
//
// let h1Tag = new HtmlBook('h1', h1Descr, h1ArtArr);
//
// console.log(h1Tag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag span ******************
//
// let spanDescr = 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов,' +
//     ' таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и' +
//     ' установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы,' +
//     ' если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый ' +
//     'раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или ' +
//     'id с именем селектора.';
//
// let spanAtrTabinObj = new HtmlAtr('tabindex', 'Устанавливает порядок получения фокуса при переходе ' +
//     'между элементами с помощью клавиши Tab.');
//
// let spanAtrLangObj = new HtmlAtr('lang', 'Браузер использует значение параметра для правильного ' +
//     'отображения некоторых национальных символов.');
//
// let spanAtrArr = [spanAtrTabinObj, spanAtrLangObj];
//
// let spanTag = new HtmlBook('span', spanDescr, spanAtrArr);
//
// console.log(spanTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag input ******************
//
// let inputDescr = 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы ' +
//     'интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания' +
//     ' текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать ' +
//     'внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены' +
//     ' на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и' +
//     ' в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.';
//
// let inputAtrTypeObj = new HtmlAtr('type', 'Сообщает браузеру, к какому типу относится элемент формы.');
//
// let inputAtrValueObj = new HtmlAtr('value', 'Определяет значение элемента формы, которое будет отправлено' +
//     ' на сервер или получено с помощью клиентских скриптов.');
//
// let inputAtrAltObj = new HtmlAtr('alt', 'Альтернативный текст для кнопки с изображением.');
//
// let inputAtrArr = [inputAtrTypeObj, inputAtrValueObj, inputAtrAltObj];
//
// let inputTag = new HtmlBook('input', inputDescr, inputAtrArr);
//
// console.log(inputTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag form ******************
//
// let formDescr = 'Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными ' +
//     'между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, ' +
//     'с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять ' +
//     'по своему усмотрению.';
//
// let formAtrActionObj = new HtmlAtr('action', 'Указывает обработчик, к которому обращаются данные формы ' +
//     'при их отправке на сервер. В качестве обработчика может выступать CGI-программа или HTML-документ, ' +
//     'который включает в себя серверные сценарии (например, Parser). После выполнения обработчиком действий по работе' +
//     ' с данными формы он возвращает новый HTML-документ.');
//
// let formAtrEnctypeObj = new HtmlAtr('enctype', 'Определяет способ кодирования данных формы при их' +
//     ' отправке на сервер. Обычно устанавливать значение атрибута enctype не требуется, данные вполне правильно ' +
//     'понимаются на стороне сервера. Однако если используется поле для отправки файла (input type="file"), следует ' +
//     'определить атрибут enctype как multipart/form-data.');
//
// let formArtMethodObj = new HtmlAtr('method', 'Атрибут method сообщает серверу о методе запроса.');
//
// let formAtrArr = [formAtrActionObj, formAtrEnctypeObj, formArtMethodObj];
//
// let formTag = new HtmlBook('form', formDescr, formAtrArr);
//
// console.log(formTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag option ******************
//
// let optionDescr = 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>.' +
//     ' Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью' +
//     ' стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы.' +
//     ' Это также необходимо, когда к данным списка идет обращение через скрипты.';
//
// let optAtrLabelObj = new HtmlAtr('label', 'Атрибут предназначен для указания метки пункта списка, ' +
//     'сокращённой по сравнению с текстом внутри <option>. Если атрибут label присутствует, то текст внутри тега <option>' +
//     ' игнорируется и в списке выводится значение label.');
//
// let optAtrDisblObj = new HtmlAtr('disabled', 'Блокирует элемент списка для его выбора');
//
// let optAtrValueObj = new HtmlAtr('value', 'Значение пункта списка, которое будет отправлено на сервер или' +
//     ' прочитано с помощью скриптов.');
//
// let optAtrArr = [optAtrLabelObj, optAtrDisblObj, optAtrValueObj];
//
// let optionTag = new HtmlBook('option', optionDescr, optAtrArr);
//
// console.log(optionTag);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag select ******************
//
// let selDescr = 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с ' +
//     'одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size ' +
//     'тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом,' +
//     ' указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью ' +
//     'тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка ' +
//     'на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка ' +
//     'идет обращение через скрипты.';
//
// let selAtrFormObj = new HtmlAtr('form', 'Связывает список с формой по её идентификатору. ' +
//     'Такая связь необходима в случае, когда список располагается за пределами <form>.');
//
// let selAtrReqObj = new HtmlAtr('required', 'Устанавливает список обязательным для выбора перед отправкой ' +
//     'формы на сервер. Если пункт списка не выбран, браузер выведет сообщение, а форма отправлена не будет.' +
//     ' Вид и содержание сообщения зависит от браузера и меняться пользователем не может.');
//
//
// let selAtrFocusObj = new HtmlAtr('autofocus', 'Атрибут autofocus устанавливает, что список получает' +
//     ' фокус после загрузки страницы, при этом список становится доступным для выбора пунктов, например, ' +
//     'с помощью клавиатуры.');
//
// let selAtrArr = [selAtrFormObj, selAtrReqObj, selAtrFocusObj];
//
// let selectTag = new HtmlBook('select', selDescr, selAtrArr);
//
// console.log(selectTag);
//
// console.log('------------------------------------------------------------------------------');
//
// // ==============================================

// ////===================================== 2 =========================================================================
//
// // ==============================================
// //     -  Створити класс  для об'єкту який описує теги
// // Властивості
// // -назва тегу
// // - опис його дій
// // - масив з атрибутами (2-3 атрибути максимум)
// // Кожен атрибут описати як окремий який буде містити
// // -назву атрибуту
// // -опис дії атрибуту
// // інформацію брати з htmlbook.ru
// //
// // Таким чином описати теги
// // -a
// // -div
// // -h1
// // -span
// // -input
// // -form
// // -option
// // -select
// // Приклад результату
// // {
// //     titleOfTag: 'area',
// //         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
// //     attrs: [
// //     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
// //     {/*some props and values*/},
// //     {/*...*/},
// //     {/*...*/},
// // ]
// //
// // }
//
// class HTMLBookClass {
//     constructor(tagName, tagDescr, tagAtrArr) {
//         this.tagName = tagName;
//         this.tagDescr = tagDescr;
//         this.attributes = [...tagAtrArr];
//     }
// }
// console.log('*************************** classes ********************************');
// //// ************** tag a class ******************
//
// let tagAClass = new HTMLBookClass('a', aDescr, aAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag div class ******************
//
// let tagDivClass = new HTMLBookClass('div', divDescr, divAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag h1 class ******************
//
// let tagH1Class = new HTMLBookClass('h1', h1Descr, h1ArtArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag span class ******************
//
// let tagSpanClass = new HTMLBookClass('span', spanDescr, spanAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag input class ******************
//
// let tagInputClass = new HTMLBookClass('input', inputDescr, inputAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag form class ******************
//
// let tagFormClass = new HTMLBookClass('form', formDescr, formAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag option class ******************
//
// let tagOptionClass = new HTMLBookClass('option', optionDescr, optAtrArr);
//
// console.log(tagAClass);
//
// console.log('------------------------------------------------------------------------------');
//
// //// ************** tag select class ******************
//
// let tagSelectClass = new HTMLBookClass('select', selDescr, selAtrArr);
//
// console.log(tagAClass);
//
// // ==============================================

////======================================= 3 ========================================================================
// // // ==============================================
// //     - Створити об'єкт testCar, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна.
// //     додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
//
// let testCarObj = {
//     model: 'passat',
//     brand: 'VW',
//     year: 1990,
//     maxSpeed: 190,
//     volEngine: 5,
//
//     drive: function () {
//         console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`);
//     },
//
//     info: function () {
//         console.log("Інфо про авто:");
//         for (const key in this) {
//             if(typeof this[key] !== 'function'){
//                 if(typeof this[key] === 'object'){
//                     console.log(`${key}: `);
//                     for (const drKey in this[key]) {
//                         console.log(`  - ${drKey}: ${this[key][drKey]}`);
//                     }
//                 }else {
//                     console.log(`${key}: ${this[key]}`);
//                 }
//             }
//         }
//     },
//
//     increaseMaxSpeed: function (newSpeed) {
//         this.maxSpeed += newSpeed;
//     },
//
//     changeYear: function (newValue) {
//         this.year = newValue;
//     },
//
//     addDriver: function (driver) {
//         this.driver = driver;
//     }
// }
//
// let driver = {name: 'Adolf', age: 50, exp: 28};
//
// testCarObj.info();
//
// testCarObj.addDriver(driver);
//
// console.log('___________________________');
//
// testCarObj.info();
// // ==============================================

////======================================== 4 =========================================================================
// // ==============================================
// //     - Створити функцію конструктор яка дозволяє створювати об'єкти car, з властивостями модель, виробник,
// //     рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
//
// function CarF(model, brand, year, maxSpeed, volEngine) {
//     this.model = model;
//     this.brand = brand;
//     this.year = year;
//     this.maxSpeed = maxSpeed;
//     this.volEngine = volEngine;
//
//     this.drive = function () {
//         console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`);
//     }
//
//     this.info = function () {
//         console.log("Інфо про авто:");
//         for (const key in this) {
//             if(typeof this[key] !== 'function'){
//                 if(typeof this[key] === 'object'){
//                     console.log(`${key}: `);
//                     for (const drKey in this[key]) {
//                         console.log(`  - ${drKey}: ${this[key][drKey]}`);
//                     }
//                 }else {
//                     console.log(`${key}: ${this[key]}`);
//                 }
//             }
//         }
//     }
//
//     this.increaseMaxSpeed = function (newSpeed){
//         this.maxSpeed += newSpeed;
//     }
//
//     this.changeYear = function (newValue){
//         this.year = newValue;
//     }
//
//     this.addDriver = function (driver){
//         this.driver = driver;
//     }
// }
//
// let testCarF = new CarF('sedan', 'opel', 1990, 100, 5);
//
// let driver = {name: 'Adolf', age: 50, exp: 28};
//
// testCarF.info();
//
// testCarF.addDriver(driver);
//
// console.log('___________________________');
//
// testCarF.info();
//
// // ==============================================

////======================================== 5 =========================================================================
// // ==============================================
// //     - Створити клас який дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна
// //     швидкість, об'єм двигуна. додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
//
// class Car {
//     constructor(model, brand, year, maxSpeed, volEngine) {
//         this.model = model;
//         this.brand = brand;
//         this.year = year;
//         this.maxSpeed = maxSpeed;
//         this.volEngine = volEngine;
//     }
//
//     drive() {
//         console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`);
//     }
//
//     info(){
//         console.log("Інфо про авто:");
//         for (const key in this) {
//             if(typeof this[key] !== 'function'){
//                 if(typeof this[key] === 'object'){
//                     console.log(`${key}: `);
//                     for (const drKey in this[key]) {
//                         console.log(`  - ${drKey}: ${this[key][drKey]}`);
//                     }
//                 }else {
//                     console.log(`${key}: ${this[key]}`);
//                 }
//             }
//         }
//     }
//
//     increaseMaxSpeed (newSpeed){
//         this.maxSpeed += newSpeed;
//     }
//
//     changeYear (newValue){
//         this.year = newValue;
//     }
//
//     addDriver (driver){
//         this.driver = driver;
//     }
// }
//
// let testCar = new Car('sedan', 'opel', 1990, 100, 5);
//
// let driver = {name: 'Adolf', age: 50, exp: 28};
//
// testCar.info();
//
// testCar.addDriver(driver);
//
// console.log('___________________________');
//
// testCar.info();
// ==============================================

////======================================== 6 =========================================================================
// // ==============================================
// //     -створити класс попелюшка з полями ім'я, вік, розмір ноги
// // --Створити 10 попелюшок , покласти їх в масив
// // --Сторити об'єкт класу "принц" за допомоги класу який має поля ім'я, вік, туфелька яку він знайшов.
// // -- за допоиоги циклу знайти яка попелюшка повинна бути з принцом
//
// class Human {
//     constructor(name, age) {
//         this.name = name;
//         this.age = age;
//     }
// }
//
// class Cinderella extends Human {
//     constructor(name, age, footSize) {
//         super(name, age);
//         this.footSize = footSize;
//     }
// }
//
// class Prince extends Human {
//     constructor(name, age, shoesSize) {
//         super(name, age);
//         this.shoesSize = shoesSize;
//     }
// }
//
// let cinderellasArray = [];
//
// for (let i = 0; i < 10; i++) {
//     cinderellasArray.push(new Cinderella(`Cindy-${i + 1}`, (+((Math.random() * 20) + 18).toFixed(0)), (+((Math.random() * (20)) + 18).toFixed(0))));
// }
//
// let prince = new Prince('Phillip', 50, (+((Math.random() * 20) + 18).toFixed(0)));
//
// console.log(`принц знайшов туфельку ${prince.shoesSize} розміру!`);
// let narechenaCount = 0;
//
// for (const cindy of cinderellasArray) {
//     if (narechenaCount < 1) {
//         if (cindy.footSize === prince.shoesSize) {
//             console.log(`з принцом повинна бути попелюшка ${cindy.name},
//             вік якої ${cindy.age}, розмір ноги ${cindy.footSize}`);
//             narechenaCount++;
//         }
//     }else {
//         break;
//     }
// }
// // ==============================================

////======================================== 7 =========================================================================
// // ==============================================
// //     -створити функцію конструктор попелюшка з полями ім'я, вік, розмір ноги
// // --Створити 10 попелюшок , покласти їх в масив
// // --Сторити об'єкт типу "принц" за допомоги функції конструктора з полями ім'я, вік, туфелька яку він знайшов, та функцію "пошук попелюшки"
// // -- функція повинна приймати масив попелюшок, та шукає ту котра йому підходить
//
// function Cinderella (name, age, footSize) {
//         this.name = name;
//         this.age = age;
//         this.footSize = footSize;
// }
//
// function Prince (name, age, shoesSize){
//         this.name = name;
//         this.age = age;
//         this.shoesSize = shoesSize;
//
//         this.cindySearh = function (cindyArray) {
//             let narechenaCount = 0;
//             for (const cindy of cindyArray) {
//                 if (narechenaCount < 1) {
//                     if (cindy.footSize === prince.shoesSize) {
//                         console.log(`з принцом повинна бути попелюшка ${cindy.name},
//             вік якої ${cindy.age}, розмір ноги ${cindy.footSize}`);
//                         narechenaCount++;
//                     }
//                 }else {
//                     break;
//                 }
//             }
//         }
// }
//
// let cinderellasArray = [];
//
// for (let i = 0; i < 10; i++) {
//     cinderellasArray.push(new Cinderella(`Cindy-${i + 1}`, (+((Math.random() * 20) + 18).toFixed(0)), (+((Math.random() * (20)) + 18).toFixed(0))));
// }
//
// let prince = new Prince('Phillip', 50, (+((Math.random() * 20) + 18).toFixed(0)));
//
// console.log(`принц знайшов туфельку ${prince.shoesSize} розміру!`);
//
// prince.cindySearh(cinderellasArray);
//
// // ==============================================